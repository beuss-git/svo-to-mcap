from rosidl_runtime_py.utilities import get_message
from rosidl_parser.definition import (
    AbstractSequence,
    AbstractString,
    BasicType,
    NamespacedType,
    Array,
)
from pathlib import Path
from typing import Set, List

# https://mcap.dev/spec/registry#ros2msg

HEADER = """// GENERATED BY generate_ros2_schemas.py
#pragma once
#include <string_view>

namespace ros2schemas {

struct SchemaInfo {
  std::string_view id;
  std::string_view schema;
};
"""

# https://wiki.ros.org/msg
ROS_TYPE_NORMALIZATION = {
    # IDL -> .msg aliases
    "boolean": "bool",
    "octet": "uint8",
    "char": "char",
    "wchar": "wchar",
    "float": "float32",
    "double": "float64",
    "long double": "float64",  # best approximation
    # Non-explicit IDL integer → .msg equivalents
    "short": "int16",
    "long": "int32",
    "long long": "int64",
    "unsigned short": "uint16",
    "unsigned long": "uint32",
    "unsigned long long": "uint64",
    # Explicit types — keep unchanged
    "int8": "int8",
    "int16": "int16",
    "int32": "int32",
    "int64": "int64",
    "uint8": "uint8",
    "uint16": "uint16",
    "uint32": "uint32",
    "uint64": "uint64",
}


def format_type(slot_type):
    if isinstance(slot_type, Array):
        base = format_type(slot_type.value_type)
        if slot_type.size is not None:
            return f"{base}[{slot_type.size}]"
        else:
            return f"{base}[]"
    elif isinstance(slot_type, AbstractSequence):
        return format_type(slot_type.value_type) + "[]"
    elif isinstance(slot_type, AbstractString):
        return "string"
    elif isinstance(slot_type, BasicType):
        base = slot_type.typename
        return ROS_TYPE_NORMALIZATION.get(base, base)
    elif isinstance(slot_type, NamespacedType):
        return "/".join(slot_type.namespaced_name())
    else:
        return str(slot_type)


def normalize_identifier(msg_type_str):
    return msg_type_str.replace("/", "_").replace(".", "_")


def collect_definition(msg_type_str, seen: Set[str], skip_first: bool = True) -> str:
    lines = []
    if msg_type_str in seen:
        return ""
    if skip_first:
        # Skip this message, but mark it as seen
        seen.add(msg_type_str)
    else:
        # Print this message
        seen.add(msg_type_str)
        MsgClass = get_message(msg_type_str)
        slots = MsgClass.__slots__
        slot_types = MsgClass.SLOT_TYPES

        lines.append("=" * 80)
        lines.append(f"MSG: {msg_type_str}")
        for name, slot_type in zip(slots, slot_types):
            clean_name = name.lstrip("_")
            lines.append(f"{format_type(slot_type)} {clean_name}")
    # Then always recurse into subfields
    sublines = []
    MsgClass = get_message(msg_type_str)
    slots = MsgClass.__slots__
    slot_types = MsgClass.SLOT_TYPES

    for name, slot_type in zip(slots, slot_types):
        elem_type = slot_type
        if isinstance(slot_type, (Array, AbstractSequence)):
            elem_type = slot_type.value_type
        if isinstance(elem_type, NamespacedType):
            nested_type = "/".join(elem_type.namespaced_name())
            nested_output = collect_definition(nested_type, seen, skip_first=False)
            if nested_output:
                sublines.append(nested_output)

    # If we skipped printing this one, just return submessages
    if skip_first:
        return "\n".join(sublines)

    return "\n".join(lines + sublines)


def generate_hpp_block(msg_type_str: str) -> str:
    MsgClass = get_message(msg_type_str)
    slots = MsgClass.__slots__
    slot_types = MsgClass.SLOT_TYPES

    lines = []
    for name, slot_type in zip(slots, slot_types):
        clean_name = name.lstrip("_")
        lines.append(f"{format_type(slot_type)} {clean_name}")

    seen = set()
    sub_definitions = collect_definition(msg_type_str, seen, skip_first=True)
    lines.append(sub_definitions)

    full_body = "\n".join(lines).strip()
    identifier = normalize_identifier(msg_type_str)

    return (
        f"static constexpr SchemaInfo {identifier} = {{\n"
        f'  .id = "{msg_type_str}",\n'
        f'  .schema = R"(\n{full_body}\n)"\n'
        f"}};"
    )


def generate_hpp(messages: List[str], output_path: str):
    lines = [HEADER]

    for msg in messages:
        print(f"Generating for {msg}...")
        block = generate_hpp_block(msg)
        lines.append(block)
        lines.append("")  # Blank line between entries

    lines.append("}  // namespace ros2schemas")
    Path(output_path).write_text("\n".join(lines))
    print(f"Header written to {output_path}")


# Example usage
if __name__ == "__main__":
    messages = [
        "sensor_msgs/msg/Image",
        "sensor_msgs/msg/CameraInfo",
        "sensor_msgs/msg/PointCloud2",
    ]
    output_file = "ros2_schemas.hpp"
    generate_hpp(messages, output_file)
